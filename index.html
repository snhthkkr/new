<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="atem">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">
  <meta name="format-detection" content="telephone=no">
  <title>atem</title>
  <link rel="manifest" href="manifest.json">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }
    
    html, body {
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      touch-action: none;
    }
    
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    /* Text editor overlay */
    #editor {
      position: fixed;
      display: none;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid rgba(96, 165, 250, 0.3);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      font-size: 17px;
      font-family: inherit;
      min-width: 140px;
      max-width: 300px;
      outline: none;
      resize: none;
      line-height: 1.5;
      z-index: 1000;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 30px rgba(96, 165, 250, 0.15);
    }
    
    #editor::placeholder {
      color: rgba(255, 255, 255, 0.25);
    }
    
    /* Daily prompt */
    #prompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 900;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    #prompt.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    #prompt-text {
      color: rgba(255, 255, 255, 0.6);
      font-size: 20px;
      font-weight: 300;
      letter-spacing: 0.02em;
      margin-bottom: 20px;
      line-height: 1.6;
    }
    
    #prompt-dismiss {
      color: rgba(255, 255, 255, 0.3);
      font-size: 13px;
      cursor: pointer;
      transition: color 0.2s;
    }
    
    #prompt-dismiss:hover {
      color: rgba(255, 255, 255, 0.6);
    }
    
    /* Stats panel */
    #stats {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.25);
      font-size: 11px;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      letter-spacing: 0.05em;
      z-index: 100;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    
    #stats span {
      margin-right: 16px;
    }
    
    /* Menu button */
    #menu-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: background 0.2s, border-color 0.2s;
    }
    
    #menu-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }
    
    #menu-btn svg {
      width: 18px;
      height: 18px;
      fill: rgba(255, 255, 255, 0.5);
    }
    
    /* Menu panel */
    #menu {
      position: fixed;
      bottom: 70px;
      right: 20px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 8px 0;
      min-width: 180px;
      z-index: 1001;
      display: none;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
    
    #menu.open { display: block; }
    
    .menu-item {
      padding: 12px 18px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    
    .menu-item:hover {
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
    }
    
    .menu-item.danger {
      color: #ef4444;
    }
    
    .menu-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.08);
      margin: 6px 0;
    }
    
    /* Sync indicator */
    #sync {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #60a5fa;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 1000;
    }
    #sync.saving { opacity: 0.6; }
    #sync.saved { opacity: 0.3; }
    
    /* Toast */
    #toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 2000;
      pointer-events: none;
    }
    #toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <textarea id="editor" placeholder="think..." rows="1"></textarea>
  
  <div id="prompt">
    <div id="prompt-text"></div>
    <div id="prompt-dismiss">tap anywhere to begin</div>
  </div>
  
  <div id="stats">
    <span id="stat-thoughts">0 thoughts</span>
    <span id="stat-connections">0 connections</span>
  </div>
  
  <button id="menu-btn">
    <svg viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
  </button>
  
  <div id="menu">
    <div class="menu-item" id="menu-export">Export JSON</div>
    <div class="menu-item" id="menu-import">Import JSON</div>
    <div class="menu-divider"></div>
    <div class="menu-item" id="menu-reset-view">Reset View</div>
    <div class="menu-item" id="menu-new-prompt">New Prompt</div>
    <div class="menu-divider"></div>
    <div class="menu-item danger" id="menu-clear">Clear All</div>
  </div>
  
  <div id="sync"></div>
  <div id="toast"></div>
  
  <input type="file" id="import-input" accept=".json" style="display:none">

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ════════════════════════════════════════════════════════════════
// Config
// ════════════════════════════════════════════════════════════════

const STORAGE_KEY = 'atem3d';
const HOLD_MS = 300;
const FLOAT_INTENSITY = 0.015;
const FLOAT_SPEED = 0.0008;
const MOMENTUM_FRICTION = 0.94;
const MOMENTUM_MIN = 0.01;

// ════════════════════════════════════════════════════════════════
// Daily Prompts
// ════════════════════════════════════════════════════════════════

const PROMPTS = [
  "what's on your mind?",
  "what did you notice today?",
  "what's unresolved?",
  "what are you avoiding?",
  "what would make today good?",
  "what's the question you're not asking?",
  "where is your attention?",
  "what's changing?",
  "what are you grateful for?",
  "what needs to be said?",
  "what are you holding onto?",
  "what would you do if you weren't afraid?",
  "what's the simplest next step?",
  "who are you becoming?",
  "what pattern do you see?",
  "what's the connection you're missing?",
  "what deserves more attention?",
  "what's ready to let go?",
  "what's emerging?",
  "what do you know that you're pretending not to know?"
];

// ════════════════════════════════════════════════════════════════
// State
// ════════════════════════════════════════════════════════════════

let state = {
  thoughts: [],
  connections: [],
  camera: { x: 0, y: 0, z: 30 },
  lastPromptDate: null
};

// ════════════════════════════════════════════════════════════════
// DOM
// ════════════════════════════════════════════════════════════════

const canvas = document.getElementById('canvas');
const editor = document.getElementById('editor');
const syncDot = document.getElementById('sync');
const toast = document.getElementById('toast');
const promptEl = document.getElementById('prompt');
const promptText = document.getElementById('prompt-text');
const statsEl = document.getElementById('stats');
const statThoughts = document.getElementById('stat-thoughts');
const statConnections = document.getElementById('stat-connections');
const menuBtn = document.getElementById('menu-btn');
const menu = document.getElementById('menu');
const importInput = document.getElementById('import-input');

// ════════════════════════════════════════════════════════════════
// Three.js Setup
// ════════════════════════════════════════════════════════════════

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Subtle fog for depth
scene.fog = new THREE.Fog(0x000000, 30, 100);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 30);

const renderer = new THREE.WebGLRenderer({ 
  canvas, 
  antialias: true,
  alpha: false
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// Orbit controls
const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.rotateSpeed = 0.5;
controls.zoomSpeed = 0.8;
controls.panSpeed = 0.5;
controls.minDistance = 5;
controls.maxDistance = 100;

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const pointLight = new THREE.PointLight(0xffffff, 0.8);
pointLight.position.set(10, 20, 15);
scene.add(pointLight);

const pointLight2 = new THREE.PointLight(0x60a5fa, 0.3);
pointLight2.position.set(-15, -10, 10);
scene.add(pointLight2);

// ════════════════════════════════════════════════════════════════
// Thought Management
// ════════════════════════════════════════════════════════════════

const thoughtMeshes = new Map();
const thoughtData = new Map(); // Extra runtime data per thought
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function createThoughtMesh(thought) {
  const geometry = new THREE.SphereGeometry(1, 32, 32);
  const material = new THREE.MeshStandardMaterial({
    color: 0x1e293b,
    roughness: 0.6,
    metalness: 0.15,
    emissive: 0x60a5fa,
    emissiveIntensity: 0.08
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(thought.x, thought.y, thought.z);
  mesh.userData.id = thought.id;
  mesh.userData.type = 'thought';
  
  scene.add(mesh);
  thoughtMeshes.set(thought.id, mesh);
  
  // Runtime data for animation
  thoughtData.set(thought.id, {
    floatOffset: Math.random() * Math.PI * 2,
    basePosition: new THREE.Vector3(thought.x, thought.y, thought.z),
    velocity: new THREE.Vector3(0, 0, 0),
    targetEmissive: 0.08
  });
  
  return mesh;
}

function addThought(x, y, z, text = '') {
  const thought = {
    id: uid(),
    x, y, z,
    text,
    created: Date.now(),
    updated: Date.now()
  };
  
  state.thoughts.push(thought);
  createThoughtMesh(thought);
  updateStats();
  save();
  
  return thought;
}

function updateThought(id, updates) {
  const thought = state.thoughts.find(t => t.id === id);
  if (thought) {
    Object.assign(thought, updates, { updated: Date.now() });
    
    // Update base position if position changed
    if (updates.x !== undefined || updates.y !== undefined || updates.z !== undefined) {
      const data = thoughtData.get(id);
      if (data) {
        data.basePosition.set(thought.x, thought.y, thought.z);
      }
    }
    
    save();
  }
}

function removeThought(id) {
  const mesh = thoughtMeshes.get(id);
  if (mesh) {
    scene.remove(mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
    thoughtMeshes.delete(id);
    thoughtData.delete(id);
  }
  state.thoughts = state.thoughts.filter(t => t.id !== id);
  state.connections = state.connections.filter(c => c.from !== id && c.to !== id);
  renderConnections();
  updateStats();
  save();
}

// ════════════════════════════════════════════════════════════════
// Connection Management
// ════════════════════════════════════════════════════════════════

const connectionLines = new Map();
let pendingLine = null;

function addConnection(fromId, toId) {
  if (fromId === toId) return null;
  
  const connection = {
    id: uid(),
    from: fromId,
    to: toId,
    created: Date.now()
  };
  
  state.connections.push(connection);
  renderConnections();
  updateStats();
  save();
  
  return connection;
}

function getConnectionKey(fromId, toId) {
  return [fromId, toId].sort().join('-');
}

function getConnectionDensity(fromId, toId) {
  const key = getConnectionKey(fromId, toId);
  return state.connections.filter(c => 
    getConnectionKey(c.from, c.to) === key
  ).length;
}

function renderConnections() {
  // Clear existing
  connectionLines.forEach(line => {
    scene.remove(line);
    line.geometry.dispose();
    line.material.dispose();
  });
  connectionLines.clear();
  
  // Group by pair
  const pairs = new Map();
  state.connections.forEach(conn => {
    const key = getConnectionKey(conn.from, conn.to);
    if (!pairs.has(key)) {
      pairs.set(key, { from: conn.from, to: conn.to, count: 0 });
    }
    pairs.get(key).count++;
  });
  
  // Create lines
  pairs.forEach((pair, key) => {
    const fromMesh = thoughtMeshes.get(pair.from);
    const toMesh = thoughtMeshes.get(pair.to);
    if (!fromMesh || !toMesh) return;
    
    const line = createConnectionLine(fromMesh, toMesh, pair.count);
    line.userData.from = pair.from;
    line.userData.to = pair.to;
    line.userData.density = pair.count;
    connectionLines.set(key, line);
    scene.add(line);
  });
}

function createConnectionLine(fromMesh, toMesh, density) {
  const curve = new THREE.LineCurve3(
    fromMesh.position.clone(),
    toMesh.position.clone()
  );
  
  // More points for smoother line
  const points = curve.getPoints(20);
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  
  // Density affects visual
  const opacity = Math.min(0.2 + density * 0.12, 0.7);
  const emissiveBoost = Math.min(density * 0.1, 0.4);
  
  const material = new THREE.LineBasicMaterial({
    color: new THREE.Color(0x60a5fa).multiplyScalar(0.8 + emissiveBoost),
    transparent: true,
    opacity: opacity
  });
  
  return new THREE.Line(geometry, material);
}

function updateConnectionPositions() {
  connectionLines.forEach((line) => {
    const fromMesh = thoughtMeshes.get(line.userData.from);
    const toMesh = thoughtMeshes.get(line.userData.to);
    if (!fromMesh || !toMesh) return;
    
    const positions = line.geometry.attributes.position.array;
    const fromPos = fromMesh.position;
    const toPos = toMesh.position;
    
    // Interpolate all points along the line
    const count = positions.length / 3;
    for (let i = 0; i < count; i++) {
      const t = i / (count - 1);
      positions[i * 3] = fromPos.x + (toPos.x - fromPos.x) * t;
      positions[i * 3 + 1] = fromPos.y + (toPos.y - fromPos.y) * t;
      positions[i * 3 + 2] = fromPos.z + (toPos.z - fromPos.z) * t;
    }
    line.geometry.attributes.position.needsUpdate = true;
  });
}

function createPendingLine() {
  const geometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(), new THREE.Vector3()
  ]);
  const material = new THREE.LineDashedMaterial({
    color: 0x60a5fa,
    transparent: true,
    opacity: 0.6,
    dashSize: 0.5,
    gapSize: 0.3
  });
  const line = new THREE.Line(geometry, material);
  line.computeLineDistances();
  line.visible = false;
  scene.add(line);
  return line;
}

function updatePendingLine(fromPos, toPos) {
  if (!pendingLine) return;
  const positions = pendingLine.geometry.attributes.position.array;
  positions[0] = fromPos.x;
  positions[1] = fromPos.y;
  positions[2] = fromPos.z;
  positions[3] = toPos.x;
  positions[4] = toPos.y;
  positions[5] = toPos.z;
  pendingLine.geometry.attributes.position.needsUpdate = true;
  pendingLine.computeLineDistances();
}

// ════════════════════════════════════════════════════════════════
// Persistence
// ════════════════════════════════════════════════════════════════

let saveTimeout = null;

function save() {
  clearTimeout(saveTimeout);
  syncDot.className = 'saving';
  
  saveTimeout = setTimeout(() => {
    state.camera = {
      x: camera.position.x,
      y: camera.position.y,
      z: camera.position.z
    };
    
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      syncDot.className = 'saved';
      setTimeout(() => syncDot.className = '', 1500);
    } catch (e) {
      console.warn('Save failed:', e);
    }
  }, 400);
}

function load() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const saved = JSON.parse(raw);
      state.thoughts = saved.thoughts || [];
      state.connections = saved.connections || [];
      state.camera = saved.camera || { x: 0, y: 0, z: 30 };
      state.lastPromptDate = saved.lastPromptDate || null;
      
      camera.position.set(state.camera.x, state.camera.y, state.camera.z);
      
      state.thoughts.forEach(t => createThoughtMesh(t));
      renderConnections();
      updateStats();
    }
  } catch (e) {
    console.warn('Load failed:', e);
  }
}

// ════════════════════════════════════════════════════════════════
// Animation - Life
// ════════════════════════════════════════════════════════════════

let time = 0;

function animateThoughts(delta) {
  time += delta;
  
  thoughtMeshes.forEach((mesh, id) => {
    const data = thoughtData.get(id);
    if (!data) return;
    
    // Gentle floating
    const floatX = Math.sin(time * FLOAT_SPEED + data.floatOffset) * FLOAT_INTENSITY;
    const floatY = Math.cos(time * FLOAT_SPEED * 1.3 + data.floatOffset) * FLOAT_INTENSITY;
    const floatZ = Math.sin(time * FLOAT_SPEED * 0.7 + data.floatOffset) * FLOAT_INTENSITY * 0.5;
    
    // Apply momentum if any
    if (data.velocity.lengthSq() > MOMENTUM_MIN * MOMENTUM_MIN) {
      data.basePosition.add(data.velocity);
      data.velocity.multiplyScalar(MOMENTUM_FRICTION);
      
      // Update state
      const thought = state.thoughts.find(t => t.id === id);
      if (thought) {
        thought.x = data.basePosition.x;
        thought.y = data.basePosition.y;
        thought.z = data.basePosition.z;
      }
    }
    
    // Final position = base + float
    mesh.position.set(
      data.basePosition.x + floatX,
      data.basePosition.y + floatY,
      data.basePosition.z + floatZ
    );
    
    // Smooth emissive transition
    const currentEmissive = mesh.material.emissiveIntensity;
    mesh.material.emissiveIntensity += (data.targetEmissive - currentEmissive) * 0.1;
  });
  
  // Update connection lines to follow thoughts
  updateConnectionPositions();
}

// ════════════════════════════════════════════════════════════════
// Interaction
// ════════════════════════════════════════════════════════════════

let isDragging = false;
let draggedMesh = null;
let dragPlane = new THREE.Plane();
let dragOffset = new THREE.Vector3();
let pointerDownTime = 0;
let pointerDownPos = { x: 0, y: 0 };
let pointerMoved = false;
let editingThought = null;
let lastDragPos = new THREE.Vector3();
let lastDragTime = 0;

// Connection state
let isConnecting = false;
let connectFromMesh = null;
let holdTimer = null;

function getIntersects(event) {
  const rect = canvas.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  pointer.set(x, y);
  raycaster.setFromCamera(pointer, camera);
  
  const meshes = Array.from(thoughtMeshes.values());
  return raycaster.intersectObjects(meshes);
}

function get3DPosition(event, z = 0) {
  const rect = canvas.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  pointer.set(x, y);
  raycaster.setFromCamera(pointer, camera);
  
  const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -z);
  const target = new THREE.Vector3();
  raycaster.ray.intersectPlane(plane, target);
  
  return target;
}

function onPointerDown(event) {
  if (event.target !== canvas) return;
  
  // Dismiss prompt if showing
  if (promptEl.classList.contains('show')) {
    dismissPrompt();
    return;
  }
  
  pointerDownTime = Date.now();
  pointerDownPos = { x: event.clientX, y: event.clientY };
  pointerMoved = false;
  
  const intersects = getIntersects(event);
  
  if (intersects.length > 0) {
    const mesh = intersects[0].object;
    
    controls.enabled = false;
    isDragging = true;
    draggedMesh = mesh;
    
    // Drag plane facing camera
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);
    dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), mesh.position);
    
    // Calculate offset
    const intersectPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPoint);
    dragOffset.subVectors(mesh.position, intersectPoint);
    
    // For momentum calculation
    lastDragPos.copy(mesh.position);
    lastDragTime = Date.now();
    
    // Visual feedback
    const data = thoughtData.get(mesh.userData.id);
    if (data) data.targetEmissive = 0.3;
    
    // Hold timer for connection mode
    holdTimer = setTimeout(() => {
      if (!pointerMoved && draggedMesh) {
        startConnecting(draggedMesh);
      }
    }, HOLD_MS);
  }
}

function startConnecting(mesh) {
  isConnecting = true;
  connectFromMesh = mesh;
  isDragging = false;
  
  // Visual feedback
  const data = thoughtData.get(mesh.userData.id);
  if (data) data.targetEmissive = 0.5;
  mesh.material.emissive.setHex(0x60a5fa);
  
  // Show pending line
  if (!pendingLine) pendingLine = createPendingLine();
  pendingLine.visible = true;
  updatePendingLine(mesh.position, mesh.position);
  
  if (navigator.vibrate) navigator.vibrate(10);
}

function endConnecting(targetMesh = null) {
  if (connectFromMesh && targetMesh && targetMesh !== connectFromMesh) {
    addConnection(connectFromMesh.userData.id, targetMesh.userData.id);
    if (navigator.vibrate) navigator.vibrate(5);
  }
  
  // Reset source
  if (connectFromMesh) {
    const data = thoughtData.get(connectFromMesh.userData.id);
    if (data) data.targetEmissive = 0.08;
    connectFromMesh.material.emissive.setHex(0x60a5fa);
  }
  
  // Hide pending line
  if (pendingLine) pendingLine.visible = false;
  
  // Reset all hover states
  thoughtMeshes.forEach((mesh, id) => {
    const data = thoughtData.get(id);
    if (data) data.targetEmissive = 0.08;
    mesh.material.emissive.setHex(0x60a5fa);
  });
  
  isConnecting = false;
  connectFromMesh = null;
}

function onPointerMove(event) {
  const dx = event.clientX - pointerDownPos.x;
  const dy = event.clientY - pointerDownPos.y;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
    pointerMoved = true;
    clearTimeout(holdTimer);
  }
  
  if (isConnecting && connectFromMesh) {
    const pos = get3DPosition(event, connectFromMesh.position.z);
    updatePendingLine(connectFromMesh.position, pos);
    
    // Highlight potential target
    const intersects = getIntersects(event);
    thoughtMeshes.forEach((mesh, id) => {
      if (mesh !== connectFromMesh) {
        const data = thoughtData.get(id);
        if (data) data.targetEmissive = 0.08;
      }
    });
    
    if (intersects.length > 0 && intersects[0].object !== connectFromMesh) {
      const target = intersects[0].object;
      const data = thoughtData.get(target.userData.id);
      if (data) data.targetEmissive = 0.4;
    }
  } else if (isDragging && draggedMesh) {
    const rect = canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    pointer.set(x, y);
    raycaster.setFromCamera(pointer, camera);
    
    const intersectPoint = new THREE.Vector3();
    if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
      const newPos = intersectPoint.add(dragOffset);
      
      // Update base position directly
      const data = thoughtData.get(draggedMesh.userData.id);
      if (data) {
        data.basePosition.copy(newPos);
        data.velocity.set(0, 0, 0); // Reset velocity while dragging
      }
      
      // For momentum: track position over time
      const now = Date.now();
      const dt = now - lastDragTime;
      if (dt > 0) {
        const vel = new THREE.Vector3().subVectors(newPos, lastDragPos).divideScalar(dt * 0.05);
        lastDragPos.copy(newPos);
        lastDragTime = now;
        if (data) data.velocity.copy(vel);
      }
      
      // Update state
      const thought = state.thoughts.find(t => t.id === draggedMesh.userData.id);
      if (thought) {
        thought.x = newPos.x;
        thought.y = newPos.y;
        thought.z = newPos.z;
      }
    }
  } else {
    // Hover effect
    const intersects = getIntersects(event);
    thoughtMeshes.forEach((mesh, id) => {
      const data = thoughtData.get(id);
      if (data && mesh !== draggedMesh) {
        data.targetEmissive = 0.08;
      }
    });
    if (intersects.length > 0 && !isDragging) {
      const data = thoughtData.get(intersects[0].object.userData.id);
      if (data) data.targetEmissive = 0.25;
    }
  }
}

function onPointerUp(event) {
  clearTimeout(holdTimer);
  
  const clickDuration = Date.now() - pointerDownTime;
  const wasQuickTap = clickDuration < 200 && !pointerMoved;
  
  if (isConnecting) {
    const intersects = getIntersects(event);
    const targetMesh = intersects.length > 0 ? intersects[0].object : null;
    endConnecting(targetMesh);
    controls.enabled = true;
  } else if (isDragging && draggedMesh) {
    const data = thoughtData.get(draggedMesh.userData.id);
    if (data) data.targetEmissive = 0.08;
    
    if (wasQuickTap) {
      openEditor(draggedMesh);
      if (data) data.velocity.set(0, 0, 0);
    } else {
      // Let momentum continue, save after it settles
      setTimeout(save, 500);
    }
    
    isDragging = false;
    draggedMesh = null;
    controls.enabled = true;
  } else if (wasQuickTap && event.target === canvas) {
    const pos = get3DPosition(event);
    const thought = addThought(pos.x, pos.y, pos.z);
    const mesh = thoughtMeshes.get(thought.id);
    openEditor(mesh);
  }
}

// ════════════════════════════════════════════════════════════════
// Text Editor
// ════════════════════════════════════════════════════════════════

function openEditor(mesh) {
  editingThought = state.thoughts.find(t => t.id === mesh.userData.id);
  if (!editingThought) return;
  
  const pos = mesh.position.clone().project(camera);
  const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
  
  editor.style.left = x + 'px';
  editor.style.top = y + 'px';
  editor.style.display = 'block';
  editor.value = editingThought.text;
  editor.focus();
  autoResizeEditor();
  
  const data = thoughtData.get(mesh.userData.id);
  if (data) data.targetEmissive = 0.4;
}

function closeEditor(shouldSave = true) {
  if (editingThought && shouldSave) {
    const newText = editor.value.trim();
    
    if (newText === '') {
      removeThought(editingThought.id);
    } else {
      updateThought(editingThought.id, { text: newText });
    }
  }
  
  if (editingThought) {
    const data = thoughtData.get(editingThought.id);
    if (data) data.targetEmissive = 0.08;
  }
  
  editor.style.display = 'none';
  editingThought = null;
}

function autoResizeEditor() {
  editor.style.height = 'auto';
  editor.style.height = Math.min(editor.scrollHeight, 200) + 'px';
}

editor.addEventListener('input', autoResizeEditor);
editor.addEventListener('blur', () => closeEditor(true));
editor.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeEditor(false);
  else if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    closeEditor(true);
  }
});

// ════════════════════════════════════════════════════════════════
// Daily Prompt
// ════════════════════════════════════════════════════════════════

function showPrompt() {
  const today = new Date().toDateString();
  
  // Show prompt if it's a new day or no thoughts yet
  if (state.lastPromptDate !== today || state.thoughts.length === 0) {
    const prompt = PROMPTS[Math.floor(Math.random() * PROMPTS.length)];
    promptText.textContent = prompt;
    promptEl.classList.add('show');
    state.lastPromptDate = today;
    save();
  }
}

function dismissPrompt() {
  promptEl.classList.remove('show');
}

function showNewPrompt() {
  const prompt = PROMPTS[Math.floor(Math.random() * PROMPTS.length)];
  promptText.textContent = prompt;
  promptEl.classList.add('show');
}

// ════════════════════════════════════════════════════════════════
// Stats
// ════════════════════════════════════════════════════════════════

function updateStats() {
  const tc = state.thoughts.length;
  const cc = state.connections.length;
  statThoughts.textContent = `${tc} thought${tc !== 1 ? 's' : ''}`;
  statConnections.textContent = `${cc} connection${cc !== 1 ? 's' : ''}`;
}

// ════════════════════════════════════════════════════════════════
// Menu
// ════════════════════════════════════════════════════════════════

let menuOpen = false;

menuBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  menuOpen = !menuOpen;
  menu.classList.toggle('open', menuOpen);
});

document.addEventListener('click', () => {
  if (menuOpen) {
    menuOpen = false;
    menu.classList.remove('open');
  }
});

document.getElementById('menu-export').addEventListener('click', () => {
  const data = JSON.stringify(state, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `atem-${new Date().toISOString().slice(0,10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showToast('Exported');
});

document.getElementById('menu-import').addEventListener('click', () => {
  importInput.click();
});

importInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const imported = JSON.parse(ev.target.result);
      
      // Clear existing
      thoughtMeshes.forEach(mesh => {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      });
      thoughtMeshes.clear();
      thoughtData.clear();
      connectionLines.forEach(line => {
        scene.remove(line);
        line.geometry.dispose();
        line.material.dispose();
      });
      connectionLines.clear();
      
      // Load imported
      state.thoughts = imported.thoughts || [];
      state.connections = imported.connections || [];
      state.thoughts.forEach(t => createThoughtMesh(t));
      renderConnections();
      updateStats();
      save();
      
      showToast('Imported');
    } catch (err) {
      showToast('Invalid file');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

document.getElementById('menu-reset-view').addEventListener('click', () => {
  camera.position.set(0, 0, 30);
  controls.target.set(0, 0, 0);
  save();
  showToast('View reset');
});

document.getElementById('menu-new-prompt').addEventListener('click', () => {
  showNewPrompt();
});

document.getElementById('menu-clear').addEventListener('click', () => {
  if (confirm('Clear all thoughts? This cannot be undone.')) {
    thoughtMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    });
    thoughtMeshes.clear();
    thoughtData.clear();
    connectionLines.forEach(line => {
      scene.remove(line);
      line.geometry.dispose();
      line.material.dispose();
    });
    connectionLines.clear();
    
    state.thoughts = [];
    state.connections = [];
    updateStats();
    save();
    showToast('Cleared');
  }
});

// ════════════════════════════════════════════════════════════════
// Toast
// ════════════════════════════════════════════════════════════════

function showToast(msg) {
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2000);
}

// ════════════════════════════════════════════════════════════════
// Event Listeners
// ════════════════════════════════════════════════════════════════

canvas.addEventListener('pointerdown', onPointerDown);
canvas.addEventListener('pointermove', onPointerMove);
canvas.addEventListener('pointerup', onPointerUp);
canvas.addEventListener('pointercancel', onPointerUp);
canvas.addEventListener('contextmenu', e => e.preventDefault());

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (editingThought) closeEditor(false);
    else if (promptEl.classList.contains('show')) dismissPrompt();
  }
});

// ════════════════════════════════════════════════════════════════
// Utils
// ════════════════════════════════════════════════════════════════

function uid() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
}

// ════════════════════════════════════════════════════════════════
// Render Loop
// ════════════════════════════════════════════════════════════════

let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  
  const now = performance.now();
  const delta = now - lastTime;
  lastTime = now;
  
  controls.update();
  animateThoughts(delta);
  renderer.render(scene, camera);
}

// ════════════════════════════════════════════════════════════════
// Init
// ════════════════════════════════════════════════════════════════

load();
pendingLine = createPendingLine();
animate();

// Show prompt after a moment
setTimeout(() => {
  if (state.thoughts.length === 0) {
    showPrompt();
  }
}, 500);

// Register service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

console.log('atem 3d - v0.3 alive');
</script>
</body>
</html>
